{"version":3,"file":"index.esm.min.js","sources":["../src/index.js"],"sourcesContent":["import { throttle, last, first } from 'lodash-es';\n\n/**\n * Calc fps based on time elapsed between animation frames.\n * @param state - observable state which value is set to current fps\n * @param observingInterval - time in ms\n */\nfunction trackFPS(state, observingInterval = 100) {\n  let timeMeasurements = [];\n\n  const tick = function() {\n    timeMeasurements.push(performance.now());\n\n    const msPassed = last(timeMeasurements) - first(timeMeasurements);\n\n    if (msPassed >= observingInterval) {\n      state.value = Math.round(timeMeasurements.length / msPassed * 1000 * 10) / 10;\n      timeMeasurements = [];\n    }\n\n    requestAnimationFrame(() => {\n      tick();\n    });\n  };\n  tick();\n}\n\n/**\n * Throttle given callback based on current FPS.\n * If FPS is lower then fpsThrottlingLimit, then throttling might be extended up to maxThrottlingTime.\n * Otherwise behaves like lodash throttling and throttle with minThrottlingTime.\n * @param FPS - observable state which value indicates current fps\n * @param FPSThrottlingLimit - FPS limit where additional throttling might occur\n * @param callback\n * @param minThrottlingTime\n * @param {maxThrottlingTime} - if not set, function behaves just like lodash throttle\n */\nconst minMaxThrottle = (FPS, FPSThrottlingLimit, callback, minThrottlingTime, maxThrottlingTime = 0) => {\n  maxThrottlingTime = Math.max(maxThrottlingTime, minThrottlingTime);\n  let time = minThrottlingTime;\n  let timeout = null;\n  const throttleFunc = (...args) => {\n    clearTimeout(timeout);\n    if (time >= maxThrottlingTime || FPS.value > FPSThrottlingLimit) {\n      time = minThrottlingTime;\n      callback(...args);\n    } else {\n      time += minThrottlingTime;\n      timeout = setTimeout(() => {\n        throttleFunc(...args);\n      }, minThrottlingTime);\n    }\n  };\n  return throttle(throttleFunc, minThrottlingTime);\n};\n\nconst FPSThrottle = {\n  install(Vue, options = {}) {\n    let FPS = options.FPS;\n    if (!options.FPS) {\n      FPS = Vue.observable({ value: 1 });\n      let observingInterval = options.observingInterval || 100;\n      trackFPS(FPS, observingInterval);\n      Vue.prototype.$FPS = FPS;\n    }\n    const FPSThrottlingLimit = options.FPSThrottlingLimit || 30;\n    Vue.prototype.$minMaxThrottle = (...args) => minMaxThrottle(FPS, FPSThrottlingLimit, ...args);\n  },\n};\n\nexport default FPSThrottle;"],"names":["install","Vue","options","FPS","observable","value","observingInterval","state","timeMeasurements","tick","push","performance","now","msPassed","last","first","Math","round","length","requestAnimationFrame","trackFPS","prototype","$FPS","FPSThrottlingLimit","$minMaxThrottle","args","callback","minThrottlingTime","maxThrottlingTime","max","time","timeout","throttle","throttleFunc","clearTimeout","setTimeout"],"mappings":"wEAwDoB,CAClBA,iBAAQC,OAAKC,yDAAU,GACjBC,EAAMD,EAAQC,QACbD,EAAQC,IAAK,CAChBA,EAAMF,EAAIG,WAAW,CAAEC,MAAO,QAC1BC,EAAoBJ,EAAQI,mBAAqB,KAtD3D,SAAkBC,OAAOD,yDAAoB,IACvCE,EAAmB,IAEV,SAAPC,IACJD,EAAiBE,KAAKC,YAAYC,WAE5BC,EAAWC,EAAKN,GAAoBO,EAAMP,GAE5CK,GAAYP,IACdC,EAAMF,MAAQW,KAAKC,MAAMT,EAAiBU,OAASL,EAAW,IAAO,IAAM,GAC3EL,EAAmB,IAGrBW,sBAAsB,WACpBV,MAGJA,GAsCIW,CAASjB,EAAKG,GACdL,EAAIoB,UAAUC,KAAOnB,MAEjBoB,EAAqBrB,EAAQqB,oBAAsB,GACzDtB,EAAIoB,UAAUG,gBAAkB,sCAAIC,2BAAAA,yBA7BjB,SAACtB,EAAKoB,EAAoBG,EAAUC,OAAmBC,yDAAoB,EAChGA,EAAoBZ,KAAKa,IAAID,EAAmBD,OAC5CG,EAAOH,EACPI,EAAU,YAaPC,EAZc,SAAfC,+BAAmBR,2BAAAA,kBACvBS,aAAaH,GACTD,GAAQF,GAAqBzB,EAAIE,MAAQkB,GAC3CO,EAAOH,EACPD,eAAYD,KAEZK,GAAQH,EACRI,EAAUI,WAAW,WACnBF,eAAgBR,IACfE,KAGuBA,kBAagCxB,EAAKoB,UAAuBE"}