{"version":3,"file":"index.min.js","sources":["../src/index.js"],"sourcesContent":["import { throttle, last, first } from 'lodash-es';\n\n/**\n * Calc fps based on time elapsed between animation frames.\n * @param state - observable state which value is set to current fps\n * @param observingInterval - time in ms\n */\nfunction trackFPS(state, observingInterval = 100) {\n  let timeMeasurements = [];\n\n  const tick = function() {\n    timeMeasurements.push(performance.now());\n\n    const msPassed = last(timeMeasurements) - first(timeMeasurements);\n\n    if (msPassed >= observingInterval) {\n      state.value = Math.round(timeMeasurements.length / msPassed * 1000 * 10) / 10;\n      timeMeasurements = [];\n    }\n\n    requestAnimationFrame(() => {\n      tick();\n    });\n  };\n  tick();\n}\n\n/**\n * Throttle given callback based on current FPS.\n * If FPS is lower then fpsThrottlingLimit, then throttling might be extended up to maxThrottlingTime.\n * Otherwise behaves like lodash throttling and throttle with minThrottlingTime.\n * @param FPS - observable state which value indicates current fps\n * @param FPSThrottlingLimit - FPS limit where additional throttling might occur\n * @param callback\n * @param minThrottlingTime\n * @param {maxThrottlingTime} - if not set, function behaves just like lodash throttle\n */\nconst minMaxThrottle = (FPS, FPSThrottlingLimit, callback, minThrottlingTime, maxThrottlingTime = 0) => {\n  maxThrottlingTime = Math.max(maxThrottlingTime, minThrottlingTime);\n  let time = minThrottlingTime;\n  let timeout = null;\n  const throttleFunc = (...args) => {\n    clearTimeout(timeout);\n    if (time >= maxThrottlingTime || FPS.value > FPSThrottlingLimit) {\n      time = minThrottlingTime;\n      callback(...args);\n    } else {\n      time += minThrottlingTime;\n      timeout = setTimeout(() => {\n        throttleFunc(...args);\n      }, minThrottlingTime);\n    }\n  };\n  return throttle(throttleFunc, minThrottlingTime);\n};\n\nconst FPSThrottle = {\n  install(Vue, options = {}) {\n    let FPS = options.FPS;\n    if (!options.FPS) {\n      FPS = Vue.observable({ value: 1 });\n      let observingInterval = options.observingInterval || 100;\n      trackFPS(FPS, observingInterval);\n      Vue.prototype.$FPS = FPS;\n    }\n    const FPSThrottlingLimit = options.FPSThrottlingLimit || 30;\n    Vue.prototype.$minMaxThrottle = (...args) => minMaxThrottle(FPS, FPSThrottlingLimit, ...args);\n  },\n};\n\nexport default FPSThrottle;"],"names":["trackFPS","state","observingInterval","timeMeasurements","tick","push","performance","now","msPassed","last","first","value","Math","round","length","requestAnimationFrame","minMaxThrottle","FPS","FPSThrottlingLimit","callback","minThrottlingTime","maxThrottlingTime","max","time","timeout","throttle","throttleFunc","args","clearTimeout","setTimeout","FPSThrottle","install","Vue","options","observable","prototype","$FPS","$minMaxThrottle"],"mappings":"+CAOA,SAASA,SAASC,OAAOC,yDAAoB,IACvCC,EAAmB,IAEV,SAAPC,IACJD,EAAiBE,KAAKC,YAAYC,WAE5BC,EAAWC,cAAKN,GAAoBO,eAAMP,GAE5CK,GAAYN,IACdD,EAAMU,MAAQC,KAAKC,MAAMV,EAAiBW,OAASN,EAAW,IAAO,IAAM,GAC3EL,EAAmB,IAGrBY,sBAAsB,WACpBX,MAGJA,GAaF,IAAMY,eAAiB,SAACC,EAAKC,EAAoBC,EAAUC,OAAmBC,yDAAoB,EAChGA,EAAoBT,KAAKU,IAAID,EAAmBD,OAC5CG,EAAOH,EACPI,EAAU,YAaPC,kBAZc,SAAfC,+BAAmBC,2BAAAA,kBACvBC,aAAaJ,GACTD,GAAQF,GAAqBJ,EAAIN,MAAQO,GAC3CK,EAAOH,EACPD,eAAYQ,KAEZJ,GAAQH,EACRI,EAAUK,WAAW,WACnBH,eAAgBC,IACfP,KAGuBA,IAG1BU,YAAc,CAClBC,iBAAQC,OAAKC,yDAAU,GACjBhB,EAAMgB,EAAQhB,QACbgB,EAAQhB,IAAK,CAChBA,EAAMe,EAAIE,WAAW,CAAEvB,MAAO,QAC1BT,EAAoB+B,EAAQ/B,mBAAqB,IACrDF,SAASiB,EAAKf,GACd8B,EAAIG,UAAUC,KAAOnB,MAEjBC,EAAqBe,EAAQf,oBAAsB,GACzDc,EAAIG,UAAUE,gBAAkB,sCAAIV,2BAAAA,yBAASX,6BAAeC,EAAKC,UAAuBS"}